== Implementing ACID transactions

ACID stands for Atomic, Consistent, Isolated and Durable. We have a (very limited) form of atomicity in our transactions right now, because we only write the changes
in the commit. That isn't nearly enough. We want to allow concurrent transactions to operate transparently, which means that we have to define _how_ they will operate.

Gavran is going to implement a model called single writer / concurrent readers. In this model, we split the transactions into two modes. We have read transactions
and a write transaction. At any given point in time, we may have any number of read transactions but only a single write transaction. Supporting multiple write 
transactions is usually something that you need to do if you have a chatty network interface, and as embedded database, that is not required for Gavran.

.Single write transaction vs. Concurrent writers
****
Most embedded databases implement some for of single write transactions. LMDB, Sqlite and Voron all share this design decision. Berkley DB has a similar 
limitation, but with Berkley DB, you can only have a single write transaction, with no concurrent read transactions.

Databases such as MySQL or PostgreSQL has the notion of concurrent write transactions, but they use a very different model. In a network database with 
transactions that involve multiple network round trips, the latency is too high to allow a single write transaction. You have to have concurrent ones and
deal with all the locking issues that this entails. 

The problem with concurrent write transactions is that they require that you'll implement locking.  In 
https://dl.acm.org/doi/full/10.1145/3226595.3226635[OLTP Through the Looking Glass, and What We Found There], about 30% of the overall performance goes 
to locking and latching to manage concurrent writers. A single threaded solution can actually be faster.
****

With concurrent readers, we need to decide on the concurrency strategy for Gavran. Take a look at Figure 13, where we show a timeline of a few transactions.

.A timeline of concurrent read transactions and a write transaction
image::{img-src}/fig13.png[]

Read transaction no. 1 was started after the write transaction and ended after the write transaction was committed. Read transaction no. 2 was created
before the write transaction and closed afterward. Only read transaction no. 3 was created after the write transaction commit. 

Gavran is going to implement *snapshot isolation* for transactions. Once a transaction is opened, it will have a consistent and unchanging view of the 
database. A write transaction commit will only impact _later_ transactions.

This behavior is the first task in the road for ACID, the question is, how are we going to implement it? 

txn_create
txn_modify_metadata
txn_get_metadata
txn_get_page
txn_modify_page
txn_commit
txn_apply
txn_cleanup
db_create