#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "database.h"
#include "private.h"
#include "errors.h"
#include "pal.h"

/*

uint64_t _size_of_free_space_bitmap_in_pages(uint64_t number_of_pages){
    uint64_t number_of_bits_required = (number_of_pages / FREE_SPACE_PAGES_BLOCK);
    uint64_t number_of_bytes_required = number_of_bits_required / 8;
    if(number_of_bits_required % 8)
        number_of_bytes_required++;
    uint64_t number_of_pages_required = number_of_bytes_required / PAGE_SIZE;
    if(number_of_bytes_required % PAGE_SIZE)
        number_of_pages_required++;
    return number_of_pages_required;
}
 
uint64_t _size_of_page_header_buffer_in_pages(uint64_t number_of_pages) {
    uint64_t size_of_page_headers_buffer = number_of_pages * sizeof(page_header_t);
    uint64_t number_of_pages_for_page_headers_buffer = size_of_page_headers_buffer / PAGE_SIZE;
    if(size_of_page_headers_buffer % PAGE_SIZE)
        number_of_pages_for_page_headers_buffer++;
    return number_of_pages_for_page_headers_buffer;
}

void _set_free_space_bitmap( char* base  PAGE_ALIGNED , file_header_t* header, uint64_t page){
     uint64_t* free_space_bitmap = (void*)(base + header->free_space_first_page * PAGE_SIZE);
     free_space_bitmap[ page / 64 ] |= 1ul << ( page % 64 );
} 

void _clear_free_space_bitmap( char* base PAGE_ALIGNED, file_header_t* header, uint64_t page){
     uint64_t* free_space_bitmap = (void*)(base + header->free_space_first_page * PAGE_SIZE);
     free_space_bitmap[ page / 64 ] &= ~(1ul << ( page % 64 ));
}

page_header_t* _get_page_header(char* base PAGE_ALIGNED, file_header_t* header, uint64_t page){
     page_header_t* buffer = (void*)(base + header->page_headers_first_page * PAGE_SIZE);
     return &buffer[page];
}
*/



bool _create_new_database(database_options_t* options, database_handle_t* database){
    file_handle_t* handle = database->file_handle;
    assert(options->minimum_size % PAGE_SIZE == 0);
    if(!ensure_file_minimum_size(handle, options->minimum_size))
        return false;

    void* address;
    if(!map_file(handle, options->minimum_size, &address)){
        push_error(ENODATA, "Unable to map file when creating new database %s", options->name);
        return false;    
    }
    database->mapped_memory = address;
    database->database_size = options->minimum_size;

    // here we can assume that the entire range is zero initialized
    uint64_t number_of_pages = options->minimum_size / PAGE_SIZE;

    file_header_t header = {
        .magic = FILE_HEADER_MAGIC_CONSTANT,
//        .last_txid = 0,
        .size_in_pages = number_of_pages,
        .last_allocated_page = 1, // exluding the header page
        .version = 1,        
    };
    /*
    header.page_headers_first_page = number_of_pages - 
                _size_of_page_header_buffer_in_pages(number_of_pages); 

    header.free_space_first_page = header.page_headers_first_page - 
                _size_of_free_space_bitmap_in_pages(number_of_pages);
    */

    char* base = address;
    // we copy the header twice on the same page, but on different sectors
    _Static_assert(PAGE_SIZE/2 >= 4096,"We need to ensure that this reside on separate sectors, and on SSD, that means 4KB apart");
    memcpy(base, &header, sizeof(header));              // PAGE 0
    memcpy(base + PAGE_SIZE/2, &header, sizeof(header));// PAGE 0.5
    memcpy(&database->current_file_header, &header, sizeof(header));

    // _set_free_space_bitmap(base, &header, 0); 
    // _get_page_header(base, &header, 0)->flags = PAGE_FLAGS_SINGLE;
    
    // _set_free_space_bitmap(base, &header, 1);
    // _get_page_header(base, &header, 1)->flags = PAGE_FLAGS_SINGLE;

    // for(uint64_t i = header.free_space_first_page; i < number_of_pages; i++){
    //     _set_free_space_bitmap(base, &header, i);
    //      _get_page_header(base, &header, i)->flags = PAGE_FLAGS_SINGLE;
    // }

    return true;
}

static bool validate_options(database_options_t* options) {
    if(options->minimum_size < MINIMUM_DATABASE_SIZE)
        options->minimum_size = MINIMUM_DATABASE_SIZE;

    if(options->minimum_size % PAGE_SIZE)
        options->minimum_size += PAGE_SIZE - (options->minimum_size % PAGE_SIZE);

    if(!options->path || !strlen(options->path)){
        push_error(EINVAL, "The database path was not specified or empty, but is required");
        return false; 
    }
    if(!options->name || !strlen(options->name)){
        push_error(EINVAL, "The database name was not specified or empty, but is required");
        return false;
    } 
    return true;
}

size_t get_database_handle_size(database_options_t* options) {
    size_t len = get_file_handle_size(options->path, options->name);
    return len + sizeof(database_handle_t);
}

bool create_database(database_options_t* options, database_handle_t* database){

    if(!validate_options(options))
        return false;

    size_t len = get_file_handle_size(options->path, options->name);
    assert(len); // shouldn't happen, already checked in validate_options

    memset(database, 0, sizeof(database) + len);

    if(!create_file(options->path, options->name, database->file_handle)){
        push_error(EIO, "Could not create database %s", options->name);
        goto exit_error;
    }
 
    if(!get_file_size(database->file_handle, &database->database_size)){
        push_error(errno, "Unable to create database %s", options->name);
        goto exit_error;
    }

    if(database->database_size == 0){
        if(!_create_new_database(options, database))
            goto exit_error;
    }
    else {
        // recover existing db
    }
    
    return true;
exit_error:
    // these can fail, but in this case, we don't care, the error is reported anyway via push_error
    // and there isn't much we can do further to handle this
    close_database(database);
    return false;
}

bool close_database(database_handle_t* database) {
    if(!database)
        return true;
    
    bool success = true;
    if(database->mapped_memory)  
        success &= unmap_file(database->mapped_memory, database->database_size);
    success &= close_file(database->file_handle);
    if(!success)
        push_error(EIO, "Failed to close database %s", get_file_name(database->file_handle));

    return success;
}

bool create_transaction(database_handle_t* database, uint32_t flags, txn_t* txn) {
    memset(txn, 0, sizeof(txn_t));

    // txn->txid = database->current_file_header.last_txid;
    // if (flags & TX_READ_WRITE)
    //     txn->txid++;

    txn->db = database;
    txn->flags = flags;
    txn->page_map = create_page_map(txn, 32);
    if (!txn->page_map) {
        push_error(ENOMEM, "Unable to allocate a page map for transaction");
        return false;
    }
    return true;
}

static void _page_map_value_destroyer(uint64_t page, page_header_t* header, void* value, void* ctx){
    (void)page;
    (void)header;
    (void)value;
    (void)ctx;
}

bool close_transaction(txn_t* tx){
    destroy_page_map(&tx->page_map, _page_map_value_destroyer, 0);
    return true;
}




// /*
// bool modify_page(txn_t* tx, uint64_t page, page_header_t** header, void** page_data) {
//     if(get_page_map(tx->page_map, page, header, page_data))
//         return true;

//     if(page > tx->db->current_file_header.size_in_pages){
//         push_error(EINVAL, "Attempted to read page %lu but the max page is %lu", page, tx->db->current_file_header.size_in_pages);
//         return false;
//     }

//     page_header_t* read_header = _get_page_header(tx->db->mapped_memory, &(tx->db->current_file_header), page);
//     void* read_data = _get_page_pointer(tx->db->mapped_memory, page);

//     uint64_t number_of_pages = 1;

//     if(read_header->flags & PAGE_FLAGS_OVERFLOW) {
//         number_of_pages = read_header->overflow_size / PAGE_SIZE + (read_header->overflow_size % PAGE_SIZE ? 1 : 0);
//     }

//     *page_data = allocate_tx_page(tx, number_of_pages);
//     if(!*page_data){
//         push_error(errno, "Unable to allocate memory for modifed copy of page %lu (%lu pages)", page, number_of_pages);
//         return false;
//     }
//     *header = allocate_tx_mem(tx, sizeof(page_header_t));
//     if (!*header){
//         push_error(ENOMEM, "Unable to allocate memory for modified page header %lu", page);
//         release_tx_page(tx, *page_data, number_of_pages);
//         *page_data = 0;
//         return false;
//     } 

//     memcpy(*header, read_header, sizeof(page_header_t));
//     memcpy(*page_data, read_data, PAGE_SIZE * number_of_pages);

//     if(!set_page_map(tx->page_map, page, *header, *page_data, &read_header, &read_data)){
//         push_error(ENOMEM, "Unable to allocate memory for transaction's page map");
//         release_tx_page(tx, *page_data, number_of_pages);
//         release_tx_mem(tx, *header);
//         *header = 0;
//         *page_data = 0;
//         return false;
//     }
//     return true;
// }

// file_header_t* get_current_file_header(txn_t* tx){
//     void* first_page_buffer = get_page_pointer(tx->db->mapped_memory, 0);
//     file_header_t* fst = (file_header_t*)first_page_buffer;
//     file_header_t* snd = (file_header_t*)((char*)first_page_buffer + PAGE_SIZE/2);
//     if (fst->last_txid > snd->last_txid)
//         return fst;
//     return snd;
// }

// */


// void* get_page_pointer(char* base PAGE_ALIGNED, uint64_t page) {
//     return (void*)(base + page * PAGE_SIZE);
// }


// size_t get_txn_size(void) { 
//     return sizeof(txn_t);
// }

// uint64_t get_txn_id(txn_t* tx) {
//     return tx->txid;
// }

// bool modify_page(txn_t* tx, uint64_t page_number, void**page_buffer, uint32_t* number_of_pages_allocated){
//     file_header_t* header = &tx->db->current_file_header;
//     if(page_number >= header->last_allocated_page){
//         push_error(EINVAL, "Page %lu was not allocated in %s", page_number, get_file_name(tx->db->file_handle));
//         return false;
//     }
//     *page_buffer = get_page_pointer(tx->db->mapped_memory, page_number);
//     *number_of_pages_allocated = 1;
//     return true;
// }

// bool allocate_page(txn_t* tx, uint32_t number_of_pages, uint32_t flags, uint64_t* page_number){
//     (void)flags; // currently unused
//     assert(number_of_pages == 1);
//     file_header_t* header = &tx->db->current_file_header;
//     if(header->last_allocated_page + number_of_pages >= header->size_in_pages){
//         push_error(ENOSPC, "Unable to allocate %u page(s) for %s because %lu pages are allocated", number_of_pages,
//             get_file_name(tx->db->file_handle), header->last_allocated_page);
//         return false;
//     }
//     *page_number  = header->last_allocated_page ;
//     header->last_allocated_page += number_of_pages;
//     return true;
// }


// // TEMP impl

// void* allocate_tx_mem(txn_t* tx, uint64_t size){
//     (void)tx;
//     return malloc(size);
// }

// void* allocate_tx_page(txn_t* tx, uint64_t number_of_pages){
//     (void)tx;
//     void*ptr; 
//     int rc = posix_memalign(&ptr, PAGE_SIZE, number_of_pages * PAGE_SIZE);
//     if(!rc)
//         return ptr;
//     errno = rc;
//     return 0;
// }

// void release_tx_mem(txn_t* tx, void* address){
//     (void)tx;
//     free(address);
// }

// void  release_tx_page(txn_t* tx, void* address, uint64_t number_of_pages){
//     (void)tx;
//     (void)number_of_pages;
//     free(address);
// }


