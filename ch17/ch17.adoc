== Multiple values in hashes and trees

In the last chapter, we build a B+Tree and earlier in the book we implemented an Extendible Hash Table. When I built them, I stated that they are going to store a single `uint64_t`
value. 
In other words, if we compare them to in memory containers,  B+Tree is a `sorted_map<span_t key, uint64_t value>` and the hash table is a 
`map<uint64_t key, { uint64_t value, uint8_t flags}>`. That works great as long as we have a single value to store, but what happens if we want to have multiple values for 
the same key?

Let's consider a usage scenario for the B+Tree, we want to store a mapping between an IP address and the time of access. I other words, we want to use a B+Tree to implement the 
following function: `result_t record_ip_access(state_t* state, char* ip_address, time_t access_time)`. For the purpose of discussion, we'll ignore the different possible encodings 
of IP addresses and just focus on the code in <<record_ips>>.

[source]
[[record_ips]]
.Recording IP addresses
----
time_t now = 1600000000; // Sep 13, 2020

ensure(record_ip_access(state, "127.0.0.1", now - 60));
ensure(record_ip_access(state, "127.0.0.1", now));
ensure(record_ip_access(state, "127.0.0.1", now + 60));
----

As you can see in <<record_ips>>, we have a problem. We need to record _multiple_ values for the same key. Right now, the B+Tree code cannot handle this scenario at all. Each key
has a single value, that is all. So how can we store multiple entries for the same key? 

The answer, for B+Trees, is actually quite simple: We aren't going to. Yet we still want to allow the code in <<record_ips>> to work, so what should we do?

A key observation here is that we don't _need_ to store all the values in a single key. To be rather more exact, the key provided to us by the caller doesn't have to be the key we
use for the B+Tree. This is exposed by the API shown in <<btree_multi_api>>.

[source]
[[btree_multi_api]]
.`gavran/db.h` - API for working with multiple values per key in a B+Tree
----
include::../include/gavran/db.h[tags=btree_multi_api]
----

You can see that the API in <<btree_multi_api>> doesn't have a `set` function but an `append` one. We also don't have a way to `get` an item from a multi value, but we have to 
iterate to get all the values. The API surface is quite different, even if the underlying implementation isn't that different. 

Conceptually, what we are going to do is to change the key that the user provided us. So the three calls we have in <<record_ips>> would result in the following entries 

The idea is that instead of writing the key as the user supplied it, we'll extend it with a unique value. Here are the actual B+Tree entries after inserting three records:

* `127.0.0.1|1` -> 1599999940
* `127.0.0.1|2` -> 1600000000
* `127.0.0.1|3` -> 1600000060

Because we have the `|1` postfix to the key, we are able to store multiple values on the same "key". 



This might be easier to explain if we'll see the code that is involved 
with adding a multi value to the tree. You can see that in <<btree_multi_append>>.


